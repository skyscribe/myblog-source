---
layout: post
title: "Pragmatic Programmer再读"
date: 2013-08-05 21:18
comments: true
categories: [programming,reading]
---

这是一本讲述程序员开发哲学和思想的书，虽然出版了十余年仍然没有太多过时的东西，因为讲述的内容是一些永远不会过时的东西（至少从计算机程序设计职业化-即所谓的软件工程开启的时间算便是如此）。

<!--more-->

## 再读机缘

初次接触到这本大作是在2008年初；当时刚刚开阔自己封闭的眼界，读到很多人的推荐都将此书列为必读的经典，于是兴冲冲的去图书馆借了过来读。草草读完心中大为触动，什么是优秀的程序员，为什么顶尖的程序员和初级程序员的生产效率相差数倍乃至更多，这本书给出了深刻的答案；虽然没有具体的技术，但是一个条目一个条目的建议和提示，辅以思考分析，当时便暗下决心要照着其中的条例去做，做到自己的极致。加上当时另外一本奇书 <<Unix 编程艺术>> 也进入了我的视野，使我彻底陷入了Unix的程序世界；两本书中的相似的哲学观点深刻的整塑着我的编程价值观。

一晃然又是五年过去了；当时的菜鸟已经慢慢成长为一个老油条；这期间总是努力迫使自己向着其中的条目去努力和进步；但是感觉上却没有太多新的东西让自己觉得太震撼了,至少是具体到编程技术上的，也许是我自己已经将这本书的原则实践的很不错了？

刚好前几天又到图书馆借书，没有找到满意的图书，却于不经意见看到了 <<编程原本>>和这本书，于是便背了回来，权当一次重新检视自己的标杆吧。

## 感悟

重新翻了一遍，当初的震撼感几乎消失殆尽了，因为书里边讲述的很多信条已经在我的大脑中成为编程习惯的一部分了，只是某些方面还没有尽力将其发挥的更远 - 也许这就是开始基础不高的时候进步总是很容易的，一旦达到一定的高度再想更进一步就难上加难了。

这里再挑几点最深的感悟：

### DRY 原则

这个原则是如此的深入人心，以至于很多设计模式和讲述重构的书都会反反复复的阐释，并且提出各自的实践。不重复自己，意味着如果某些事情中有很多重复，并且是人工维护的，就很容易出错并慢慢变得越来越难以维护。久而久之代码就会慢慢失去活力，腐败并产生Smelly,可以说这一原则是其它所有重要的原则的基础。尽量避免重复，就自然的避免拷贝/粘帖，逼迫自己用无重复的方式去改进实现，优雅的设计自然就慢慢演变出来。没有一个优秀的设计是充满重复的。如果有，那么也是计算机来重复执行，譬如写一个生成器一样的东西。

### 自动化手工操作

这个其实是更深层次的DRY应用 - 如果发现总是重复的跑一些命令或者操作一些步骤，那么就尽量的将其自动化。自己写脚本也好，寻找更有些的工具也好，一旦将其自动化，这些繁琐的东西就不会再浪费你太多的精力，这样你就可以花更少的时间来做更多的工作；将浪费的时间用来做重要的事情，自然效率大大增加。寻找自动化工具的努力什么时候都不会太浪费。手工的操作速度再快，绝大部分情况也赶不上计算机那么准确和快速。

### 命令行工具

Bash的威力是巨大的，当然只有比较深度的Linux用户才能理解的更透彻。各种丰富的小工具和基于管道的组合可以产生巨大的威力，即使面临更先进的python/ruby这些新潮语言的挑战，很多时候原始的grep/awk/sed组合也有超强的优势 - 尤其当效率是个重要因素的时候。根源嘛，这些程序可是用纯C写的，而且诞生于资源紧张的年代，每一片代码都经过经心的调整以保证最佳效率。我们现在已经不这么写应用程序了，但是这些已有的强大的小工具，用好还是可以令人效率急速飙升的。

### 学习多种编程语言

编程语言是程序员思考的工具，遗憾的是每种编程语言都有很多的边界。这些边界也在潜意识中阻碍了程序员的视野，使得很多时候难以发现最合适的方案和最优雅的做法。打破这一障碍的方法就是经常学习新的编程语言，尤其是思路不同的程序语言，对你的世界观影响更大。每个优秀的程序员，个人认为至少应该掌握几种编程范式的语言中的一种：

1. 过程式
1. 面向对象  
1. 声明式
1. 函数式

当然更新的语言往往集成了更多的语言特性；而且在运用前边的原则的时候，有时候为了拿到顺手的工具就不可避免要学习新的编程语言。有实际需求驱动的语言学习往往能取得更好的效果，比如之前我为了做个效率更高的日志分析统计工具，专门花了一段时间学习gawk的手册，写了几百行代码之后，这些经验就在我的脑子中累计屏在日后发挥了很多的作用。


